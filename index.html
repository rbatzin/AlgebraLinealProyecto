<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora</title>
    <link rel="stylesheet" href="CSS/style.css">
</head>
<body>

    <!-- Barra de navegación -->
    <header class="navbar">
        <div class="logo"><a class="link" href="#MenuInicio">GeoAlgebra</a></div>
        <nav>
  <div class="nav-iconos">
    
    <a href="https://www.umg.edu.gt/">
    <img src="CSS/IMG/LogoUMG.png" alt="Nosotros" class="nav-icon">
</a> 
     
  </div>
</nav>
        <button class="btn-empezar">Empezar</button>
    </header>

    <!-- Sección principal -->
<section id="MenuInicio" class="hero">
    <div class="hero-content" >
        <p class="subtitulo">Proyecto Algebra Lineal</p>
          <h1 class="titulo">Matriz Gauss Jordan</h1>
          <a href="#historia"> <button class="btn-comenzar" >COMENZAR</button> </a>
    </div>
</section>
    <!-- Navegación - Menu que acompaña por toda la pagina -->
    <div class="hero-nav">
        <a href="#historia">Historia</a>
        <a href="#instrucciones">Instrucciones</a>
        <a href="#calculadora">Calculadora</a>
        <a href="#proyecto">Proyecto</a>
    </div>

<!-- Section Historia -->      
<section id="historia" class="section">
  <h2>Historia</h2>
  <div class="historia-contenido">
  <!-- Imagen y nombre de GAUSS -->   
    <div class="autor">
      <img class="ImgMat izquierda" src="CSS/IMG/GaussAnimado.png" alt="Gauss animado">
      <p class="nombre">Carl Friedrich Gauss</p>
    </div>
  <!-- Texto Centro Seccion Historia -->   
    <div class="texto-centro">
      <p>
        El método de eliminación de Gauss fue desarrollado por Carl Friedrich Gauss para resolver sistemas de ecuaciones lineales 
        mediante transformaciones matriciales. Más tarde, Wilhelm Jordan extendió este método para llevar la matriz a una forma reducida, 
        permitiendo resolver sistemas directamente y calcular inversas. Esta evolución dio lugar al método conocido como Gauss-Jordan.
      </p>
    </div>
  <!-- Imagen y nombre de Jordan -->     
    <div class="autor">
      <img class="ImgMat derecha" src="CSS/IMG/JordanAnimado.png" alt="Jordan animado">
      <p class="nombre">Wilhelm Jordan</p>
    </div>
    
  </div>
</section>

<!-- Section instrucciones -->  
<section id="instrucciones" class="section">
  <h2>Instrucciones</h2>
  
  <div class="instrucciones-contenido">
    
    <div class="texto-instrucciones">
      <h2>¿Como usar la calcualdora?</h2>
      <ol>
        <li> Dirigite hacia la seccion de "Calculadora".</li>
        <li> Haz clic en uno de los botones para generar 
          la cuadrícula correspondiente al tamaño de tu sistema de ecuaciones.</li> 
        <li> Ingresa los Valores en cada una de las casillas. Asegúrate de incluir los términos 
          independientes en la última columna.</li>
        <li> Una vez que todos los campos estén completos, 
          presiona el botón "Calcular" para iniciar el algoritmo de Gauss-Jordan.</li>
         <li>La caja de resultados se llenará automáticamente, 
          mostrándote cada paso que realiza el método.</li> 
      </ol>
   </div>
    
    <div class="galeria-minimalista"> <div class="galeria-carrusel"> 
        <img src="CSS/IMG/Paso1Imagen.png" alt="Foto de galería 1">
        <img src="CSS/IMG/Paso2Imagen.png" alt="Foto de galería 2">
        <img src="CSS/IMG/Paso3Imagen.png" alt="Foto de galería 3">
        <img src="CSS/IMG/Paso4Imagen.png" alt="Foto de galería 4">
      </div>
    </div>
    
  </div>
</section>

<!-- Section Calculadora -->  
<section id="calculadora" class="section">
  <h2>Calculadora</h2>
<!-- Botones de la Calculadora -->  
  <div class="panel-superior">
    <div class="botones-tamano">
      <button onclick="generarMatriz2x2()">2×2</button>
      <button onclick="generarMatriz3x3()">3×3</button>
      <button onclick="generarMatriz4x4()">4×4</button>
      <button onclick="generarMatriz5x5()">5×5</button>
    </div>
    <div class="separador">|</div>
    <div class="boton-calcular">
<!-- Boton de Calcular -->        
      <button onclick="resolverSistema()">Calcular</button>
    </div>
  </div>
  <div class="panel-resultado">
    <h3 id="titulo-sistema">Ingresa los valores del sistema:</h3>
    <div id="matriz-caja" class="matriz-caja"></div>
    <div id="resultado" class="resultado-caja"></div>
  </div>
</section>

<!-- SCRIPT: Sistema 2×2 -->
<script>
/**
 * -----------------------------------------------------------------
 * FUNCIÓN 1: generarMatriz2x2
 * -----------------------------------------------------------------
 */
function generarMatriz2x2() {
  // Guardamos internamente que estamos trabajando con un sistema 2x2.
  sistemaActual = "2x2";

  // Buscamos en el HTML la "caja" principal donde irán los campos.
  const caja = document.getElementById("matriz-caja");
  
  // Borramos cualquier cosa que hubiera antes en esa caja (campos de un cálculo anterior).
  caja.innerHTML = "";
  
  // También limpiamos el área donde se mostraron los resultados anteriores.
  document.getElementById("resultado").innerHTML = "";
  
  // Actualizamos el título en la página para que el usuario sepa qué hacer.
  document.getElementById("titulo-sistema").textContent = "Sistema 2×2: Ingresa los valores";

  // Definimos los textos de ayuda (placeholders) que irán dentro de cada campo.
  // Son las variables del sistema: x1, x2, r1 (resultado 1) y así.
  const nombres = [
    ["x1", "x2", "r1"],
    ["y1", "y2", "r2"]
  ];

  // Empezamos a crear los campos, fila por fila.
  // Este primer "for" crea las 2 filas.
  for (let i = 0; i < 2; i++) {
    
    // Este segundo "for" crea las 3 columnas (para x, y, y el resultado).
    for (let j = 0; j < 3; j++) {
      
      // Creamos un elemento <input> (un campo de texto) en memoria.
      const input = document.createElement("input");
      
      // Le decimos que este campo solo debe aceptar números.
      input.type = "number";
      
      // Le ponemos el texto de ayuda que definimos antes (ej: "x1").
      input.placeholder = nombres[i][j];
      
      // Le damos un ID único (ej: "m00", "m01") para poder leer su valor después.
      input.id = `m${i}${j}`;
      
      // Añadimos el campo de texto a la "caja" en la página web.
      caja.appendChild(input);
    }
  }

  // Finalmente, le decimos a la "caja" que organice los campos en una
  // cuadrícula de 3 columnas, para que se vea ordenado.
  caja.style.gridTemplateColumns = "repeat(3, 80px)";
}


/**
 * -----------------------------------------------------------------
 * FUNCIÓN 2: resolverSistema2x2
 * -----------------------------------------------------------------
 */
function resolverSistema2x2() {
  // 1. LECTURA DE DATOS
  // -------------------
  
  // Hacemos una lista de los IDs de todos los campos que creamos (m00, m01, etc.).
  const ids = ["m00", "m01", "m02", "m10", "m11", "m12"];
  
  // Leemos el valor de cada campo usando su ID y lo convertimos a número.
  const valores = ids.map(id => parseFloat(document.getElementById(id)?.value));

  // Verificamos si el usuario dejó algún campo vacío.
  if (valores.some(isNaN)) {
    // Si falta alguno, mostramos una alerta y detenemos el cálculo.
    alert("Por favor, completa todos los campos.");
    return;
  }

  // Asignamos los números leídos a variables con nombres más claros (álgebra).
  let [a1, b1, c1, a2, b2, c2] = valores;
  
  // Organizamos los números en la "Matriz Aumentada".
  // Esta es la representación de nuestro sistema de ecuaciones.
  let m = [
    [a1, b1, c1],
    [a2, b2, c2]
  ];

  // Buscamos la "caja" de resultados y la limpiamos.
  const resultado = document.getElementById("resultado");
  resultado.innerHTML = "";

  // Mostramos al usuario la matriz original antes de empezar a modificarla.
  // (La función "mostrarPaso" no está aquí, pero es la que usarían para imprimir la matriz).
  mostrarPaso("Matriz inicial", m);

  
  // 2. PROCESO DE GAUSS-JORDAN (ELIMINACIÓN)
  // ----------------------------------------
  // El objetivo es transformar la matriz [a, b, c] [d, e, f]
  // en la matriz identidad [1, 0, X] [0, 1, Y]
  // donde X e Y serán las respuestas.

  // --- PASO 1: Convertir el primer pivote (esquina superior izq.) en 1 ---
  let pivote1 = m[0][0]; // Tomamos el valor de la esquina (m[0][0])
  for (let j = 0; j < 3; j++) m[0][j] /= pivote1; // Dividimos TODA la Fila 1 por ese valor.
  mostrarPaso("Paso 1: F1 = F1 / Pivote (convertir pivote 1 a 1)", m);

  // --- PASO 2: Convertir el número DEBAJO del primer pivote en 0 ---
  let factor = m[1][0]; // Guardamos el número que queremos eliminar (m[1][0])
  // A la Fila 2, le restamos la Fila 1 multiplicada por ese 'factor'.
  for (let j = 0; j < 3; j++) m[1][j] -= factor * m[0][j];
  mostrarPaso("Paso 2: F2 = F2 - (Factor * F1) (eliminar debajo del pivote)", m);

  // --- PASO 3: Convertir el segundo pivote (centro) en 1 ---
  let pivote2 = m[1][1]; // Tomamos el valor del centro (m[1][1])
  for (let j = 0; j < 3; j++) m[1][j] /= pivote2; // Dividimos TODA la Fila 2 por ese valor.
  mostrarPaso("Paso 3: F2 = F2 / Pivote (convertir pivote 2 a 1)", m);

  // --- PASO 4: Convertir el número ARRIBA del segundo pivote en 0 ---
  factor = m[0][1]; // Guardamos el número que queremos eliminar (m[0][1])
  // A la Fila 1, le restamos la Fila 2 multiplicada por ese 'factor'.
  for (let j = 0; j < 3; j++) m[0][j] -= factor * m[1][j];
  mostrarPaso("Paso 4: F1 = F1 - (Factor * F2) (eliminar arriba del pivote)", m);


  // 3. MOSTRAR LA SOLUCIÓN
  // -----------------------
  
  // Después del Paso 4, la matriz tiene la forma:
  // [ 1,  0,  ValorX ]
  // [ 0,  1,  ValorY ]
  
  // La solución de 'x' es el último número de la primera fila.
  let x = m[0][2];
  // La solución de 'y' es el último número de la segunda fila.
  let y = m[1][2];

  // Creamos un elemento HTML para mostrar el texto de la solución.
  const solucion = document.createElement("div");
  solucion.className = "resultado-final";
  
  // Preparamos el texto final, redondeando los resultados a 2 decimales.
  solucion.innerHTML = `<strong>Solución final:</strong><br>
                        x = ${x.toFixed(2)}<br>
                        y = ${y.toFixed(2)}`;
  
  // Agregamos el texto de la solución a la "caja" de resultados en la página.
  resultado.appendChild(solucion);
}
</script>

<!-- SCRIPT: Sistema 3x3 -->
<script>
/**
 * -----------------------------------------------------------------
 * FUNCIÓN 1: generarMatriz3x3
 * -----------------------------------------------------------------
 */
function generarMatriz3x3() {
  // Guardamos internamente que estamos trabajando con un sistema 3x3.
  sistemaActual = "3x3";

  // Buscamos en el HTML la "caja" principal donde irán los campos.
  const caja = document.getElementById("matriz-caja");

  // Borramos cualquier cosa que hubiera antes en esa caja (campos de un 2x2 o 4x4).
  caja.innerHTML = "";
  
  // También limpiamos el área donde se mostraron los resultados anteriores.
  document.getElementById("resultado").innerHTML = "";
  
  // Actualizamos el título en la página para el usuario.
  document.getElementById("titulo-sistema").textContent = "Sistema 3×3: Ingresa los valores";

  // Empezamos a crear los campos, fila por fila.
  // Este primer "for" crea las 3 filas (i = 0, 1, 2).
  for (let i = 0; i < 3; i++) {
    
    // Este segundo "for" crea las 4 columnas (j = 0, 1, 2, 3).
    // Son 3 columnas para las variables (X, Y, Z) y 1 para el resultado.
    for (let j = 0; j < 4; j++) {
      
      // Creamos un elemento <input> (un campo de texto).
      const input = document.createElement("input");
      
      // Le decimos que este campo solo debe aceptar números.
      input.type = "number";
      
      // Le ponemos un texto de ayuda (placeholder).
      // Si es una columna de variable (j < 3), pone "a11", "a12", etc.
      // Si es la columna de resultado, pone "b1", "b2", etc.
      input.placeholder = j < 3 ? `a${i+1}${j+1}` : `b${i+1}`;
      
      // Le damos un ID único (ej: "m00", "m01") para poder leer su valor después.
      input.id = `m${i}${j}`;
      
      // Añadimos el campo de texto a la "caja" en la página web.
      caja.appendChild(input);
    }
  }
  // Finalmente, le decimos a la "caja" que organice los campos en una
  // cuadrícula de 4 columnas, para que se vea ordenado.
  caja.style.gridTemplateColumns = "repeat(4, 80px)";
}

/**
 * -----------------------------------------------------------------
 * FUNCIÓN 2: resolverSistema3x3
 * -----------------------------------------------------------------

 */
function resolverSistema3x3() {
  // Buscamos la "caja" de resultados y la limpiamos.
  const resultado = document.getElementById("resultado");
  resultado.innerHTML = "";

  // 1. LECTURA DE DATOS
  // -------------------

  // Definimos la variable clave 'n'. Todo el algoritmo se basa en este
  // número. Para este caso, n = 3.
  const n = 3; 
  
  // Creamos un arreglo (una lista) vacío que contendrá nuestra matriz.
  const A = [];

  // Leemos los datos de la interfaz.
  // Este "for" recorre las 3 filas.
  for (let i = 0; i < n; i++) {
    // Creamos un arreglo para la fila actual.
    const fila = [];
    
    // Este "for" recorre las 4 columnas (n + 1).
    for (let j = 0; j < n + 1; j++) {
      // Leemos el valor del campo (ej: "m00", "m01") y lo convertimos a número.
      const val = parseFloat(document.getElementById(`m${i}${j}`)?.value);
      
      // Verificamos si el usuario dejó algún campo vacío.
      if (isNaN(val)) {
        // Si falta alguno, mostramos una alerta y detenemos el cálculo.
        alert("Por favor, completa todos los campos.");
        return;
      }
      // Añadimos el número a la fila actual.
      fila.push(val);
    }
    // Añadimos la fila completa a nuestra matriz 'A'.
    A.push(fila);
  }

  // Mostramos al usuario la matriz original antes de empezar.
  // (La función "mostrarPaso" es la que imprime la matriz en la pantalla).
  // Se usa "JSON.parse(JSON.stringify(A))" para enviar una COPIA de la matriz
  // y no la original, evitando problemas.
  mostrarPaso("Matriz aumentada inicial", JSON.parse(JSON.stringify(A)));

  
  // 2. ALGORITMO DE GAUSS-JORDAN (Versión general)
  // ---------------------------------------------
  // Este "for" principal recorre cada fila (y columna) para procesar
  // el "pivote" (el elemento en la diagonal principal).
  for (let i = 0; i < n; i++) {
    
    // --- PASO 1: PIVOTEO (Asegurar que el pivote no sea CERO) ---
    // Comprobamos si el elemento diagonal A[i][i] es cero (o casi cero).
    if (Math.abs(A[i][i]) < 1e-9) { 
      let cambio = false;
      // Si es cero, buscamos una fila DEBAJO de la actual (k = i + 1).
      for (let k = i + 1; k < n; k++) {
        // Que SÍ tenga un número distinto de cero en esa misma columna.
        if (Math.abs(A[k][i]) > 1e-9) {
          // Si la encontramos, intercambiamos la Fila 'i' con la Fila 'k'.
          [A[i], A[k]] = [A[k], A[i]];
          cambio = true;
          mostrarPaso(`Intercambio F${i+1} ↔ F${k+1}`, JSON.parse(JSON.stringify(A)));
          break; // Dejamos de buscar.
        }
      }
      // Si buscamos en todas las filas de abajo y no encontramos
      // ninguna para intercambiar (todas son cero), el sistema
      // no tiene solución única.
      if (!cambio) {
        resultado.innerHTML = "<strong>El sistema no tiene solución única.</strong>";
        return; // Detenemos el algoritmo.
      }
    }

    // --- PASO 2: NORMALIZAR (Convertir el pivote en 1) ---
    // Guardamos el valor del pivote (ej: A[0][0], luego A[1][1], etc.)
    let pivote = A[i][i];
    
    // Si el pivote no es 1, lo convertimos.
    if (Math.abs(pivote - 1.0) > 1e-9) {
      // Dividimos TODOS los elementos de la fila 'i' por el valor del pivote.
      for (let j = 0; j < n + 1; j++) A[i][j] /= pivote;
      mostrarPaso(`Normalizar F${i+1} (F${i+1} / ${pivote.toFixed(2)})`, JSON.parse(JSON.stringify(A)));
    }

    // --- PASO 3: ELIMINAR (Convertir los otros números de la columna en 0) ---
    // Este "for" recorre TODAS las filas (k = 0, 1, 2).
    for (let k = 0; k < n; k++) {
      // Excepto la fila del pivote que estamos usando (k !== i).
      if (k !== i) {
        // 'factor' es el número que queremos eliminar (ej: A[1][0] o A[2][0]).
        let factor = A[k][i];
        
        // Si el 'factor' no es cero...
        if (Math.abs(factor) > 1e-9) {
          // Aplicamos la operación: Fila(k) = Fila(k) - factor * Fila(i)
          // Esto lo hacemos para cada elemento 'j' de la fila 'k'.
          for (let j = 0; j < n + 1; j++) {
            A[k][j] -= factor * A[i][j];
          }
          // Mostramos el paso: (ej: -3.00×F1 + F2 → F2)
          mostrarPaso(`${-factor.toFixed(2)}×F${i+1} + F${k+1} → F${k+1}`, JSON.parse(JSON.stringify(A)));
        }
      }
    }
  } // Fin del bucle principal 'i'. El algoritmo terminó.

  
  // 3. MOSTRAR LA SOLUCIÓN
  // -----------------------
  // Después del algoritmo, la matriz tiene la forma:
  // [ 1, 0, 0, ValorX ]
  // [ 0, 1, 0, ValorY ]
  // [ 0, 0, 1, ValorZ ]

  // Creamos un elemento HTML para mostrar el texto de la solución.
  const solucion = document.createElement("div");
  solucion.className = "resultado-final";
  
  // Preparamos el texto final.
  let solHTML = `<strong>Solución final:</strong><br>`;
  
  // La solución X es el último número (columna n) de la primera fila (fila 0).
  solHTML += `X = ${A[0][n].toFixed(2)}<br>`;
  // La solución Y es el último número de la segunda fila.
  solHTML += `Y = ${A[1][n].toFixed(2)}<br>`;
  // La solución Z es el último número de la tercera fila.
  solHTML += `Z = ${A[2][n].toFixed(2)}<br>`;
  solHTML += "<br>Proceso completado :)";
  
  // Ponemos el texto en el elemento.
  solucion.innerHTML = solHTML;
  // Agregamos el elemento a la "caja" de resultados en la página.
  resultado.appendChild(solucion);
}
</script>

<!-- SCRIPT: Sistema 4x4 -->
<script>
/**
 * -----------------------------------------------------------------
 * FUNCIÓN 1: generarMatriz4x4
 * -----------------------------------------------------------------
 */
function generarMatriz4x4() {
  // Guardamos internamente que estamos trabajando con un sistema 4x4.
  sistemaActual = "4x4";

  // Buscamos en el HTML la "caja" principal donde irán los campos.
  const caja = document.getElementById("matriz-caja");

  // Borramos cualquier cosa que hubiera antes en esa caja.
  caja.innerHTML = "";
  
  // También limpiamos el área donde se mostraron los resultados anteriores.
  document.getElementById("resultado").innerHTML = "";
  
  // Actualizamos el título en la página para el usuario.
  document.getElementById("titulo-sistema").textContent = "Sistema 4×4: Ingresa los valores";

  // Empezamos a crear los campos, fila por fila.
  // Este primer "for" crea las 4 filas (i = 0, 1, 2, 3).
  for (let i = 0; i < 4; i++) {
    
    // Este segundo "for" crea las 5 columnas (j = 0, 1, 2, 3, 4).
    // Son 4 columnas para las variables (W, X, Y, Z) y 1 para el resultado.
    for (let j = 0; j < 5; j++) {
      
      // Creamos un elemento <input> (un campo de texto).
      const input = document.createElement("input");
      
      // Le decimos que este campo solo debe aceptar números.
      input.type = "number";
      
      // Le ponemos un texto de ayuda (placeholder).
      // Si es una columna de variable (j < 4), pone "a11", "a12", etc.
      // Si es la columna de resultado, pone "b1", "b2", etc.
      input.placeholder = j < 4 ? `a${i+1}${j+1}` : `b${i+1}`;
      
      // Le damos un ID único (ej: "m00", "m01") para poder leer su valor después.
      input.id = `m${i}${j}`;
      
      // Añadimos el campo de texto a la "caja" en la página web.
      caja.appendChild(input);
    }
  }

  // Finalmente, le decimos a la "caja" que organice los campos en una
  // cuadrícula de 5 columnas, para que se vea ordenado.
  caja.style.gridTemplateColumns = "repeat(5, 80px)";
}

/**
 * -----------------------------------------------------------------
 * FUNCIÓN 2: resolverSistema4x4
 * -----------------------------------------------------------------
 */
function resolverSistema4x4() {
  // Buscamos la "caja" de resultados y la limpiamos.
  const resultado = document.getElementById("resultado");
  resultado.innerHTML = "";

  // 1. LECTURA DE DATOS
  // -------------------

  // Definimos la variable clave 'n'. Todo el algoritmo se basa en este
  // número. Para este caso, n = 4.
  const n = 4;
  
  // Creamos un arreglo (una lista) vacío que contendrá nuestra matriz.
  const A = [];

  // Leemos los datos de la interfaz.
  // Este "for" recorre las 4 filas.
  for (let i = 0; i < n; i++) {
    // Creamos un arreglo para la fila actual.
    const fila = [];
    
    // Este "for" recorre las 5 columnas (n + 1).
    for (let j = 0; j < n + 1; j++) {
      // Leemos el valor del campo (ej: "m00") y lo convertimos a número.
      const val = parseFloat(document.getElementById(`m${i}${j}`)?.value);
      
      // Verificamos si el usuario dejó algún campo vacío.
      if (isNaN(val)) {
        // Si falta alguno, mostramos una alerta y detenemos el cálculo.
        alert("Por favor, completa todos los campos.");
        return;
      }
      // Añadimos el número a la fila actual.
      fila.push(val);
    }
    // Añadimos la fila completa a nuestra matriz 'A'.
    A.push(fila);
  }

  // Mostramos al usuario la matriz original antes de empezar.
  // Se usa "JSON.parse(JSON.stringify(A))" para enviar una COPIA de la matriz
  // y no la original, evitando problemas.
  mostrarPaso("Matriz aumentada inicial", JSON.parse(JSON.stringify(A)));

  
  // 2. ALGORITMO DE GAUSS-JORDAN (Versión general)
  // ---------------------------------------------
  // Este "for" principal recorre cada fila (y columna) para procesar
  // el "pivote" (el elemento en la diagonal principal A[i][i]).
  for (let i = 0; i < n; i++) {
    
    // --- PASO 1: PIVOTEO (Asegurar que el pivote no sea CERO) ---
    // Comprobamos si el elemento diagonal A[i][i] es cero (o casi cero).
    if (Math.abs(A[i][i]) < 1e-9) {
      let cambio = false;
      // Si es cero, buscamos una fila DEBAJO de la actual (k = i + 1).
      for (let k = i + 1; k < n; k++) {
        // Que SÍ tenga un número distinto de cero en esa misma columna.
        if (Math.abs(A[k][i]) > 1e-9) {
          // Si la encontramos, intercambiamos la Fila 'i' con la Fila 'k'.
          [A[i], A[k]] = [A[k], A[i]];
          cambio = true;
          mostrarPaso(`Intercambio F${i+1} ↔ F${k+1}`, JSON.parse(JSON.stringify(A)));
          break; // Dejamos de buscar.
        }
      }
      // Si buscamos en todas las filas de abajo y no encontramos
      // ninguna para intercambiar (todas son cero), el sistema
      // no tiene solución única.
      if (!cambio) {
        resultado.innerHTML = "<strong>No hay solución.</strong>";
        return; // Detenemos el algoritmo.
      }
    }

    // --- PASO 2: NORMALIZAR (Convertir el pivote en 1) ---
    // Guardamos el valor del pivote (ej: A[0][0], luego A[1][1], etc.)
    let pivote = A[i][i];
    
    // Si el pivote no es 1, lo convertimos.
    if (Math.abs(pivote - 1.0) > 1e-9) {
      // Dividimos TODOS los elementos de la fila 'i' por el valor del pivote.
      for (let j = 0; j < n + 1; j++) A[i][j] /= pivote;
      mostrarPaso(`Normalizar F${i+1}`, JSON.parse(JSON.stringify(A)));
    }

    // --- PASO 3: ELIMINAR (Convertir los otros números de la columna en 0) ---
    // Este "for" recorre TODAS las filas (k = 0, 1, 2, 3).
    for (let k = 0; k < n; k++) {
      // Excepto la fila del pivote que estamos usando (k !== i).
      if (k !== i) {
        // 'factor' es el número que queremos eliminar (ej: A[1][0] o A[2][0]).
        let factor = A[k][i];
        
        // Si el 'factor' no es cero...
        if (Math.abs(factor) > 1e-9) {
          // Aplicamos la operación: Fila(k) = Fila(k) - factor * Fila(i)
          // Esto lo hacemos para cada elemento 'j' de la fila 'k'.
          for (let j = 0; j < n + 1; j++) {
            A[k][j] -= factor * A[i][j];
          }
          // Mostramos el paso: (ej: 5.00×F1 + F2 → F2)
          // Nota: El signo está invertido en el texto, pero la operación es correcta.
          mostrarPaso(`${factor.toFixed(2)}×F${i+1} + F${k+1} → F${k+1}`, JSON.parse(JSON.stringify(A)));
        }
      }
    }
  } // Fin del bucle principal 'i'. El algoritmo terminó.

  
  // 3. MOSTRAR LA SOLUCIÓN
  // -----------------------
  // Después del algoritmo, la matriz tiene la forma:
  // [ 1, 0, 0, 0, ValorW ]
  // [ 0, 1, 0, 0, ValorX ]
  // [ 0, 0, 1, 0, ValorY ]
  // [ 0, 0, 0, 1, ValorZ ]

  // Creamos un elemento HTML para mostrar el texto de la solución.
  const solucion = document.createElement("div");
  solucion.className = "resultado-final";
  
  // Preparamos el texto final.
  // Las soluciones están en la última columna (índice 4, que es 'n').
  solucion.innerHTML = `<strong>Solución final:</strong><br>` +
    `W = ${A[0][4].toFixed(2)}<br>` + // Fila 0, Columna 4
    `X = ${A[1][4].toFixed(2)}<br>` + // Fila 1, Columna 4
    `Y = ${A[2][4].toFixed(2)}<br>` + // Fila 2, Columna 4
    `Z = ${A[3][4].toFixed(2)}<br><br>Proceso completado :)`; // Fila 3, Columna 4
  
  // Agregamos el elemento a la "caja" de resultados en la página.
  resultado.appendChild(solucion);
}
</script>

<!-- SCRIPT: Sistema 5×5 -->
<script>
/**
 * -----------------------------------------------------------------
 * FUNCIÓN 1: generarMatriz5x5
 * -----------------------------------------------------------------
 */
function generarMatriz5x5() {
  // Guardamos internamente que estamos trabajando con un sistema 5x5.
  sistemaActual = "5x5";

  // Buscamos en el HTML la "caja" principal donde irán los campos.
  const caja = document.getElementById("matriz-caja");

  // Borramos cualquier cosa que hubiera antes en esa caja.
  caja.innerHTML = "";
  
  // También limpiamos el área donde se mostraron los resultados anteriores.
  document.getElementById("resultado").innerHTML = "";
  
  // Actualizamos el título en la página para el usuario.
  document.getElementById("titulo-sistema").textContent = "Sistema 5×5: Ingresa los valores";

  // Empezamos a crear los campos, fila por fila.
  // Este primer "for" crea las 5 filas (i = 0, 1, 2, 3, 4).
  for (let i = 0; i < 5; i++) {
    
    // Este segundo "for" crea las 6 columnas (j = 0, 1, 2, 3, 4, 5).
    // Son 5 columnas para las variables y 1 para el resultado.
    for (let j = 0; j < 6; j++) {
      
      // Creamos un elemento <input> (un campo de texto).
      const input = document.createElement("input");
      
      // Le decimos que este campo solo debe aceptar números.
      input.type = "number";
      
      // Le ponemos un texto de ayuda (placeholder).
      // Si es una columna de variable (j < 5), pone "a11", "a12", etc.
      // Si es la columna de resultado (j=5), pone "b1", "b2", etc.
      input.placeholder = j < 5 ? `a${i+1}${j+1}` : `b${i+1}`;
      
      // Le damos un ID único (ej: "m00", "m01") para poder leer su valor después.
      input.id = `m${i}${j}`;
      
      // Añadimos el campo de texto a la "caja" en la página web.
      caja.appendChild(input);
    }
  }
  // Finalmente, le decimos a la "caja" que organice los campos en una
  // cuadrícula de 6 columnas, para que se vea ordenado.
  caja.style.gridTemplateColumns = "repeat(6, 80px)";
}

// --- ESTA ES LA FUNCIÓN MEJORADA ---
/**
 * -----------------------------------------------------------------
 * FUNCIÓN 2: resolverSistema5x5
 * -----------------------------------------------------------------
 */
function resolverSistema5x5() {
  // Buscamos la "caja" de resultados y la limpiamos.
  const resultado = document.getElementById("resultado");
  resultado.innerHTML = "";

  // 1. LECTURA DE DATOS
  // -------------------

  // Definimos la variable clave 'n'. Todo el algoritmo se basa en este
  // número. Para este caso, n = 5.
  const n = 5; // <--- ÚNICO CAMBIO DE LÓGICA (antes era 4)
  
  // Creamos un arreglo (una lista) vacío que contendrá nuestra matriz.
  const A = [];

  // Leemos los datos de la interfaz.
  // Este "for" recorre las 5 filas.
  for (let i = 0; i < n; i++) {
    // Creamos un arreglo para la fila actual.
    const fila = [];
    
    // Este "for" recorre las 6 columnas (n + 1).
    for (let j = 0; j < n + 1; j++) {
      // Leemos el valor del campo (ej: "m00") y lo convertimos a número.
      const val = parseFloat(document.getElementById(`m${i}${j}`)?.value);
      
      // Verificamos si el usuario dejó algún campo vacío.
      if (isNaN(val)) {
        // Si falta alguno, mostramos una alerta y detenemos el cálculo.
        alert("Por favor, completa todos los campos.");
        return;
      }
      // Añadimos el número a la fila actual.
      fila.push(val);
    }
    // Añadimos la fila completa a nuestra matriz 'A'.
    A.push(fila);
  }

  // Mostramos al usuario la matriz original antes de empezar.
  // Se usa "JSON.parse(JSON.stringify(A))" para enviar una COPIA de la matriz
  // y no la original, evitando problemas.
  mostrarPaso("Matriz aumentada inicial", JSON.parse(JSON.stringify(A)));

  
  // 2. ALGORITMO DE GAUSS-JORDAN (Versión general)
  // ---------------------------------------------
  // Este "for" principal recorre cada fila (y columna) para procesar
  // el "pivote" (el elemento en la diagonal principal A[i][i]).
  for (let i = 0; i < n; i++) {
    
    // --- PASO 1: PIVOTEO (Asegurar que el pivote no sea CERO) ---
    // Comprobamos si el elemento diagonal A[i][i] es cero (o casi cero).
    if (Math.abs(A[i][i]) < 1e-9) {
      let cambio = false; // Variable para saber si logramos intercambiar
      // Si es cero, buscamos una fila DEBAJO de la actual (k = i + 1).
      for (let k = i + 1; k < n; k++) {
        // Que SÍ tenga un número distinto de cero en esa misma columna.
        if (Math.abs(A[k][i]) > 1e-9) {
          // Si la encontramos, intercambiamos la Fila 'i' con la Fila 'k'.
          [A[i], A[k]] = [A[k], A[i]]; // Intercambiar filas
          cambio = true; // Marcamos que sí pudimos cambiar
          // --- MUESTRA EL PASO ---
          mostrarPaso(`Intercambio F${i+1} ↔ F${k+1}`, JSON.parse(JSON.stringify(A)));
          break; // Dejamos de buscar.
        }
      }
      // Si buscamos en todas las filas de abajo y no encontramos
      // ninguna para intercambiar (todas son cero), el sistema
      // no tiene solución única.
      if (!cambio) {
        resultado.innerHTML = "<strong>El sistema no tiene solución única.</strong>";
        return; // Detenemos el algoritmo.
      }
    }

    // --- PASO 2: NORMALIZAR (Convertir el pivote en 1) ---
    // Guardamos el valor del pivote (ej: A[0][0], luego A[1][1], etc.)
    // En este punto, sabemos que NO es cero gracias al Paso 1.
    let pivote = A[i][i];
    
    // Si el pivote no es 1 (con un margen de error), lo convertimos.
    if (Math.abs(pivote - 1.0) > 1e-9) {
      // Dividimos TODOS los elementos de la fila 'i' por el valor del pivote.
      for (let j = 0; j < n + 1; j++) A[i][j] /= pivote;
       // --- MUESTRA EL PASO ---
      mostrarPaso(`Normalizar F${i+1} (F${i+1} / ${pivote.toFixed(2)})`, JSON.parse(JSON.stringify(A)));
    }

    // --- PASO 3: ELIMINAR (Convertir los otros números de la columna en 0) ---
    // Este "for" recorre TODAS las filas (k = 0, 1, 2, 3, 4).
    for (let k = 0; k < n; k++) {
      // Excepto la fila del pivote que estamos usando (k !== i).
      if (k !== i) {
        // 'factor' es el número que queremos eliminar (ej: A[1][0] o A[2][0]).
        let factor = A[k][i];
        
        // Si el 'factor' no es cero (si ya es cero, no hacemos nada)...
        if (Math.abs(factor) > 1e-9) {
          // Aplicamos la operación: Fila(k) = Fila(k) - factor * Fila(i)
          // Esto lo hacemos para cada elemento 'j' de la fila 'k'.
          for (let j = 0; j < n + 1; j++) {
            A[k][j] -= factor * A[i][j];
          }
           // --- MUESTRA EL PASO ---
           // (Se muestra -factor porque la operación es "Resta", que es "Sumar el negativo")
          mostrarPaso(`${-factor.toFixed(2)}×F${i+1} + F${k+1} → F${k+1}`, JSON.parse(JSON.stringify(A)));
        }
      }
    }
  } // Fin del bucle principal 'i'. El algoritmo terminó.

  
  // 3. MOSTRAR LA SOLUCIÓN
  // -----------------------
  // Después del algoritmo, la matriz tiene la forma:
  // [ 1, 0, 0, 0, 0, ValorX1 ]
  // [ 0, 1, 0, 0, 0, ValorX2 ]
  // [ 0, 0, 1, 0, 0, ValorX3 ]
  // [ 0, 0, 0, 1, 0, ValorX4 ]
  // [ 0, 0, 0, 0, 1, ValorX5 ]

  // Creamos un elemento HTML para mostrar el texto de la solución.
  const solucion = document.createElement("div");
  solucion.className = "resultado-final";
  
  // Genera el HTML de la solución dinámicamente
  // Empezamos el texto.
  let solHTML = `<strong>Solución final:</strong><br>`;
  
  // Hacemos un bucle de 'n' (5) vueltas para imprimir cada resultado.
  for (let i = 0; i < n; i++) {
    // La solución 'x(i+1)' está en la fila 'i', columna 'n' (la última).
    solHTML += `x${i+1} = ${A[i][n].toFixed(2)}<br>`; // A[i][n] es la columna de resultados
  }
  solHTML += "<br>Proceso completado :)";
  
  // Ponemos el texto en el elemento.
  solucion.innerHTML = solHTML;
  // Agregamos el elemento a la "caja" de resultados en la página.
  resultado.appendChild(solucion);
}
</script>

<!-- SCRIPT: Función de control y visualización -->
<script>
// Inicia en null para saber si el usuario ha presionado un botón
let sistemaActual = null; 

function resolverSistema() {
  const resultado = document.getElementById("resultado");
  resultado.innerHTML = ""; // Limpia resultados antes de empezar

  if (sistemaActual === "2x2") {
    resolverSistema2x2();
  } else if (sistemaActual === "3x3") { // <-- AQUÍ ESTÁ EL CAMBIO
    resolverSistema3x3();
  } else if (sistemaActual === "4x4") {
    resolverSistema4x4();
  } else if (sistemaActual === "5x5") {
    resolverSistema5x5(); 
  } else {
    // Maneja el caso donde no se ha seleccionado nada
    resultado.innerHTML = "<strong>Por favor, selecciona un tamaño de matriz primero.</strong>";
  }
}

function mostrarPaso(titulo, matriz) {
  const paso = document.createElement("div");
  paso.className = "paso";
  
  const matrizHTML = matriz.map(fila => 
    `[ ${fila.map(n => n.toFixed(2).padStart(7, ' ')).join("   ")} ]`
  ).join("<br>");

  paso.innerHTML = `<strong>${titulo}</strong><br><pre>${matrizHTML}</pre>`;
  
  const resultadoCaja = document.getElementById("resultado");
  resultadoCaja.appendChild(paso);
  
  // Scroll automático al fondo para ver el último paso
  resultadoCaja.scrollTop = resultadoCaja.scrollHeight;
}
</script>

<!-- Section proyecto --> 
<section id="proyecto" class="section">
  <h2>Nuestro Proyecto</h2>
  
  <div class="proyecto-contenido">
    
    <div class="video-columna">
           <iframe src="https://drive.google.com/file/d/1RTJ9IakOOF5oWsbMx117NQjMHOj1vbuu/preview?usp=sharing" width="100%" 
        allow="autoplay"
        allowfullscree frameborder="0">
    </div>
    
<div class="info-recuadros">

  <div class="recuadro">
    <div class="recuadro-logo">
      <img src="CSS/IMG/ImagenHTML.png" alt="Logo del Proyecto">
    </div>
    <div class="recuadro-info">
      <h4>HTML</h4>
      <p>Se usó HTML para definir la estructura de la página. Esto incluye las secciones, 
      los campos de texto y los contenedores que reciben y muestran los resultados.</p>
    </div>
  </div>

  <div class="recuadro">
    <div class="recuadro-logo">
      <img src="CSS/IMG/ImagenCSS.png" alt="Logo del Proyecto">
    </div>
    <div class="recuadro-info">
      <h4>CSS</h4>
      <p>CSS fue el encargado de todo el diseño visual. Definió los colores, 
        las fuentes, y el acomodo de los elementos. Haciendo la interfaz grafica con la que interactuamos.</p>
    </div>
  </div>

  <div class="recuadro">
    <div class="recuadro-logo">
      <img src="CSS/IMG/ImagenJavascript.png" alt="Logo del Proyecto">
    </div>
    <div class="recuadro-info">
      <h4>JavaScript</h4>
      <p>JavaScript le da toda la interactividad a la página. Es el cerebro que genera las matrices, 
        lee los valores que ingresas, mostrando cada paso.</p>
    </div>
  </div>

  <div class="recuadro">
    <div class="recuadro-logo">
      <img src="CSS/IMG/ImagenC++.png" alt="Logo del Proyecto">
    </div>
    <div class="recuadro-info">
      <h4>C++</h4>
      <p>Aquí nació la lógica pura del proyecto. Usamos C++ para diseñar y probar el algoritmo. 
        Esos códigos iniciales fueron la base fundamental que luego se tradujo a JavaScript.</p>
    </div>
  </div>

</div>
    
  </div>
</section>

<footer class="site-footer">
  <div class="footer-container">
    
    <div class="footer-column">
      <h4>Genios del Álgebra</h4> <p>Un proyecto interactivo para la visualización y resolución de sistemas de ecuaciones lineales mediante el método de Gauss-Jordan.</p>
    </div>
    
    <div class="footer-column">
      <h4>Navegación</h4>
      <ul>
        <li><a href="#historia">Historia</a></li>
        <li><a href="#instrucciones">Instrucciones</a></li>
        <li><a href="#calculadora">Calculadora</a></li>
        <li><a href="#proyecto">Nuestro Proyecto</a></li>
      </ul>
    </div>
    
    <div class="footer-column">
      <h4>Integrantes Del Proyecto</h4>
      <p>Roberto Ixbalamke Batzin Noj</p>
      <p>Zayra Elena Sanchez Esquito</p>
      <p>Juan David Santos Ruiz</p>
    </div>
    
    
  </div>
  
  <div class="footer-bottom">
    <p>&copy; 2025 Genios del Álgebra. Todos los derechos reservados.</p>
  </div>
</footer>    

    <script>
    window.addEventListener('scroll', function() {
        const heroNav = document.querySelector('.hero-nav');
        if (window.scrollY > window.innerHeight * 0.5) {
            heroNav.classList.add('scrolled');
        } else {
            heroNav.classList.remove('scrolled');
        }
    });
    </script>


</body>
</html>


